"""Test Quality Assurance Agent."""

import json
from pathlib import Path
from tempfile import TemporaryDirectory
from unittest.mock import MagicMock, patch

import pytest

from agents.quality_assurance import QualityAssuranceAgent


@pytest.fixture
def agent():
    """Create QualityAssuranceAgent with mocked config."""
    mock_config = {
        "scheduling": {
            "opencode_url": "http://127.0.0.1:4096",
            "auto_commit": False,
        },
        "opencode": {
            "model": "glm-4.7-free",
            "provider": "opencode",
        },
        "general": {
            "journal_directory": "/tmp/test_journal",
        },
        "quality": {
            "min_commits_for_section": 3,
        },
    }

    with patch("agents.quality_assurance.get_config", return_value=mock_config):
        with patch("agents.quality_assurance.OpenCodeClient") as mock_client:
            agent = QualityAssuranceAgent()
            agent.client = mock_client.return_value
            yield agent


@pytest.fixture
def sample_content():
    """Provide sample journal entry content."""
    return """# December 31, 2025

**Work Summary:** ~8.5 hours, ~4,800 lines - Auto-generated by journal automation

## Summary
Focused on test-repo improvements.

## Repositories Worked On
- `~/code/test-repo` (43 commits)
- **Total: 43 commits**

## test-repo
**Features**
- Feat: Add new feature

---

## Projects Legend

### test-repo
Test repository description
"""


@pytest.fixture
def sample_git_data():
    """Provide sample git data."""
    return {
        "date": "2025-12-31",
        "is_work_day": True,
        "total_commits": 43,
        "total_loc_added": 4000,
        "total_loc_deleted": 800,
        "estimated_hours": 8.5,
        "repos": {
            "test-repo": {
                "commits": 43,
                "commits_by_category": {"feat": 25, "fix": 10, "refactor": 5, "docs": 3},
                "top_features": ["feat: add feature"],
            }
        },
    }


def test_validate_and_commit_pass(agent, sample_content, sample_git_data):
    """Test validation and commit with passing score."""
    agent.client.chat.return_value = json.dumps(
        {"score": 85, "reasoning": "Good quality", "suggestions": [], "strengths": []}
    )

    with patch("agents.quality_assurance.validate_markdown_syntax", return_value=[]):
        result = agent.validate_and_commit(sample_content, sample_git_data, "2025-12-31")

    assert result["status"] == "pass"
    assert result["overall_score"] == 85
    assert result["file_path"] != ""


def test_validate_and_commit_low_score(agent, sample_content, sample_git_data):
    """Test validation with low score."""
    agent.client.chat.return_value = json.dumps(
        {
            "score": 60,
            "reasoning": "Low quality",
            "suggestions": ["Improve formatting"],
            "strengths": [],
        }
    )

    with patch("agents.quality_assurance.validate_markdown_syntax", return_value=[]):
        result = agent.validate_and_commit(sample_content, sample_git_data, "2025-12-31")

    assert result["status"] == "fail"
    assert result["overall_score"] == 60


def test_validate_and_commit_syntax_errors(agent, sample_content, sample_git_data):
    """Test validation with syntax errors."""
    agent.client.chat.return_value = json.dumps(
        {"score": 80, "reasoning": "Good", "suggestions": [], "strengths": []}
    )

    with patch(
        "agents.quality_assurance.validate_markdown_syntax", return_value=["Unclosed code block"]
    ):
        result = agent.validate_and_commit(sample_content, sample_git_data, "2025-12-31")

    assert result["status"] == "fail"
    assert "Syntax:" in result["issues"][0]


def test_validate_and_commit_critical_issue(agent, sample_content, sample_git_data):
    """Test validation with critical issue."""
    agent.client.chat.return_value = json.dumps(
        {
            "score": 85,
            "reasoning": "Good but has critical issue",
            "suggestions": [],
            "strengths": [],
        }
    )

    with patch(
        "agents.quality_assurance.validate_markdown_syntax", return_value=["critical: major error"]
    ):
        result = agent.validate_and_commit(sample_content, sample_git_data, "2025-12-31")

    assert result["status"] == "fail"


def test_validate_and_commit_error(agent, sample_content, sample_git_data):
    """Test validation with an exception."""
    with patch(
        "agents.quality_assurance.validate_markdown_syntax", side_effect=Exception("Test error")
    ):
        result = agent.validate_and_commit(sample_content, sample_git_data, "2025-12-31")

    assert result["status"] == "fail"
    assert "error" in result["reasoning"].lower()


def test_review_quality(agent):
    """Test quality review with LLM."""
    agent.client.chat.return_value = json.dumps(
        {
            "score": 90,
            "reasoning": "Excellent",
            "suggestions": ["Add more detail"],
            "strengths": ["Good structure"],
        }
    )

    result = agent._review_quality("content", {"repos": {}}, "2025-12-31")

    assert result["score"] == 90
    assert result["reasoning"] == "Excellent"
    assert len(result["suggestions"]) == 1


def test_review_quality_invalid_json(agent):
    """Test quality review with invalid JSON response."""
    agent.client.chat.return_value = {"content": "invalid json"}

    result = agent._review_quality("content", {"repos": {}}, "2025-12-31")

    assert result["score"] == 70  # Default score
    assert len(result["suggestions"]) == 0


def test_review_quality_json_extracted_from_response(agent):
    """Test quality review when JSON is embedded in response."""
    agent.client.chat.return_value = {
        "content": 'Here is the review: {"score": 75, "reasoning": "Good", "suggestions": [], "strengths": []}'
    }

    result = agent._review_quality("content", {"repos": {}}, "2025-12-31")

    assert result["score"] == 75


def test_check_cross_references_pass(agent, sample_content, sample_git_data):
    """Test cross-reference check with valid references."""
    issues = agent._check_cross_references(sample_content, sample_git_data)

    assert len(issues) == 0


def test_check_cross_references_missing_repo(agent, sample_content):
    """Test cross-reference check with missing repo."""
    git_data = {
        "repos": {
            "missing-repo": {
                "commits": 10,
                "commits_by_category": {},
                "top_features": [],
            }
        }
    }

    issues = agent._check_cross_references(sample_content, git_data)

    assert len(issues) > 0
    assert any("missing-repo" in issue for issue in issues)


def test_check_cross_references_extra_in_legend(agent):
    """Test cross-reference check with extra repo in legend."""
    git_data = {"repos": {}}
    content = """## Projects Legend
### extra-repo
Description
"""

    issues = agent._check_cross_references(content, git_data)

    assert len(issues) > 0


def test_create_journal_file(agent, sample_content):
    """Test creating journal file."""
    with TemporaryDirectory() as tmpdir:
        journal_dir = Path(tmpdir)

        with patch("agents.quality_assurance.Path") as mock_path:
            mock_path.home.return_value = Path(tmpdir)
            mock_path.return_value = journal_dir / "2025" / "12" / "31.md"
            mock_path.expanduser.return_value = journal_dir

            result = agent._create_journal_file(sample_content, "2025-12-31")

            assert result != ""
            file_path = journal_dir / result
            assert file_path.exists()


def test_create_journal_file_permissions(agent, sample_content):
    """Test that journal file has correct permissions."""
    with TemporaryDirectory() as tmpdir:
        journal_dir = Path(tmpdir)

        with patch("agents.quality_assurance.Path") as mock_path:
            mock_path.home.return_value = Path(tmpdir)
            mock_path.return_value = journal_dir / "2025" / "12" / "31.md"
            mock_path.expanduser.return_value = journal_dir

            result = agent._create_journal_file(sample_content, "2025-12-31")

            file_path = journal_dir / result
            stat = file_path.stat()

            # Check file is readable and not writable by group/others
            assert stat.st_mode & 0o644 == 0o644


def test_create_journal_file_invalid_date(agent, sample_content):
    """Test creating journal file with invalid date."""
    with pytest.raises(ValueError):
        agent._create_journal_file(sample_content, "invalid-date")


def test_commit_file_success(agent):
    """Test committing file successfully."""
    with patch("agents.quality_assurance.stage_and_commit", return_value=True):
        result = agent._commit_file("2025/12/31.md", "2025-12-31")

        assert result is True


def test_commit_file_failure(agent):
    """Test committing file when git fails."""
    with patch("agents.quality_assurance.stage_and_commit", return_value=False):
        result = agent._commit_file("2025/12/31.md", "2025-12-31")

        assert result is False


def test_validate_and_commit_auto_commit_enabled(agent, sample_content, sample_git_data):
    """Test validation with auto-commit enabled."""
    agent.client.chat.return_value = json.dumps(
        {"score": 85, "reasoning": "Good", "suggestions": [], "strengths": []}
    )

    with (
        patch("agents.quality_assurance.validate_markdown_syntax", return_value=[]),
        patch("agents.quality_assurance.stage_and_commit", return_value=True),
    ):
        # Enable auto-commit
        agent.config["scheduling"]["auto_commit"] = True

        result = agent.validate_and_commit(sample_content, sample_git_data, "2025-12-31")

    assert result["status"] == "pass"
    assert result["committed"] is True


def test_validate_and_commit_no_work_day(agent, sample_git_data):
    """Test validation for non-work day."""
    git_data = {
        "date": "2025-12-31",
        "is_work_day": False,
        "total_commits": 0,
        "repos": {},
    }

    content = """# December 31, 2025
## Summary
No work today.
"""

    agent.client.chat.return_value = json.dumps(
        {"score": 85, "reasoning": "Good", "suggestions": [], "strengths": []}
    )

    with patch("agents.quality_assurance.validate_markdown_syntax", return_value=[]):
        result = agent.validate_and_commit(content, git_data, "2025-12-31")

    assert result["status"] == "pass"


def test_review_quality_includes_reasoning(agent):
    """Test that quality review includes reasoning."""
    agent.client.chat.return_value = json.dumps(
        {
            "score": 80,
            "reasoning": "Good structure with minor issues",
            "suggestions": ["Fix formatting"],
            "strengths": ["Clear content"],
        }
    )

    result = agent._review_quality("content", {"repos": {}}, "2025-12-31")

    assert "reasoning" in result
    assert len(result["reasoning"]) > 0


def test_validate_and_commit_preserves_content(agent, sample_content, sample_git_data):
    """Test that validation preserves original content."""
    agent.client.chat.return_value = json.dumps(
        {"score": 85, "reasoning": "Good", "suggestions": [], "strengths": []}
    )

    with (
        patch("agents.quality_assurance.validate_markdown_syntax", return_value=[]),
        patch("builtins.open", MagicMock()) as mock_open,
    ):
        mock_file = MagicMock()
        mock_open.return_value.__enter__.return_value = mock_file

        agent.validate_and_commit(sample_content, sample_git_data, "2025-12-31")

        # Check that content was written
        mock_file.write.assert_called_once()
        written_content = mock_file.write.call_args[0][0]
        assert written_content == sample_content
